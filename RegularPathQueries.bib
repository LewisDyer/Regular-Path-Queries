@article{ackermanEfficientEnumerationWords2009,
  title = {Efficient Enumeration of Words in Regular Languages},
  author = {Ackerman, Margareta and Shallit, Jeffrey},
  year = {2009},
  month = sep,
  journal = {Theoretical Computer Science},
  series = {Implementation and {{Application}} of {{Automata}} ({{CIAA}} 2007)},
  volume = {410},
  number = {37},
  pages = {3461--3470},
  issn = {0304-3975},
  doi = {10.1016/j.tcs.2009.03.018},
  urldate = {2023-03-28},
  abstract = {The cross-section enumeration problem is to list all words of length n in a regular language L in lexicographical order. The enumeration problem is to list the first m words in L according to radix order. We present an algorithm for the cross-section enumeration problem that is linear in n+t, where t is the output size. We provide a detailed analysis of the asymptotic running time of our algorithm and that of known algorithms for both enumeration problems. We discuss some shortcomings of the enumeration algorithm found in the Grail computation package. In the practical domain, we modify M\"akinen's enumeration algorithm to get an algorithm that is usually the most efficient in practice. We performed an extensive performance analysis of the new and previously known enumeration and cross-section enumeration algorithms and found when each algorithm is preferable.},
  langid = {english},
  keywords = {Enumeration,Lexicographical order,NFA,Regular language},
  file = {C\:\\Users\\Lewis\\Zotero\\storage\\XFXRM63G\\Ackerman and Shallit - 2009 - Efficient enumeration of words in regular language.pdf;C\:\\Users\\Lewis\\Zotero\\storage\\KY8B52W9\\S0304397509002345.html}
}

@article{baganTrichotomyRegularSimple2020,
  title = {A Trichotomy for Regular Simple Path Queries on Graphs},
  author = {Bagan, Guillaume and Bonifati, Angela and Groz, Benoit},
  year = {2020},
  month = mar,
  journal = {Journal of Computer and System Sciences},
  volume = {108},
  pages = {29--48},
  issn = {0022-0000},
  doi = {10.1016/j.jcss.2019.08.006},
  urldate = {2023-03-22},
  abstract = {We focus on the computational complexity of regular simple path queries (RSPQs). We consider the following problem RSPQ(L) for a regular language L: given an edge-labeled digraph G and two nodes x and y, is there a simple path from x to y that forms a word belonging to L? We fully characterize the frontier between tractability and intractability for RSPQ(L). More precisely, we prove RSPQ(L) is either Image 1, Image 2-complete or Image 3-complete depending on the language L. We also provide a simple characterization of the tractable fragment in terms of regular expressions. Finally, we also discuss the complexity of deciding whether a language L belongs to the fragment above. We consider several alternative representations of L: DFAs, NFAs or regular expressions, and prove that this problem is Image 4-complete for the first representation and Image 5-complete for the other two.},
  langid = {english},
  keywords = {Automata,Complexity,Graphs,Paths,Regular languages,Regular simple paths},
  file = {C\:\\Users\\Lewis\\Zotero\\storage\\67578IF9\\1-s2.0-S0022000018305312-main.pdf;C\:\\Users\\Lewis\\Zotero\\storage\\H3SRXXK2\\1-s2.0-S0022000018305312-main.pdf}
}

@article{bonifatiAnalyticalStudyLarge2020,
  title = {An Analytical Study of Large {{SPARQL}} Query Logs},
  author = {Bonifati, Angela and Martens, Wim and Timm, Thomas},
  year = {2020},
  month = may,
  journal = {The VLDB Journal},
  volume = {29},
  number = {2},
  pages = {655--679},
  issn = {0949-877X},
  doi = {10.1007/s00778-019-00558-9},
  urldate = {2023-03-24},
  abstract = {With the adoption of RDF as the data model for Linked Data and the Semantic Web, query specification from end users has become more and more common in SPARQL endpoints. In this paper, we conduct an in-depth analytical study of the queries formulated by end users and harvested from large and up-to-date structured query logs from a wide variety of RDF data sources. As opposed to previous studies, ours is the first assessment on a voluminous query corpus, spanning over several years and covering many representative SPARQL endpoints. Apart from the syntactical structure of the queries that exhibits already interesting results on this generalized corpus, we drill deeper in the structural characteristics related to the graph and hypergraph representation of queries. We outline the most common shapes of queries when visually displayed as undirected graphs and characterize their treewidth, length of their cycles, maximal degree of nodes, and more. For queries that cannot be adequately represented as graphs, we investigate their hypergraphs and hypertreewidth. Moreover, we analyze the evolution of queries over time, by introducing the novel concept of a streak, i.e., a sequence of queries that appear as subsequent modifications of a seed query. Our study offers several fresh insights on the already rich query features of real SPARQL queries formulated by real users and brings us to draw a number of conclusions and pinpoint future directions for SPARQL query evaluation, query optimization, tuning, and benchmarking.},
  langid = {english},
  keywords = {Knowledge graph,Query log analysis,Query shapes,SPARQL endpoint,Streak analysis,Structural analysis},
  file = {C\:\\Users\\Lewis\\Zotero\\storage\\UHGL7WM8\\Bonifati et al. - 2020 - An analytical study of large SPARQL query logs.pdf}
}

@inproceedings{jhaPathSamplingFast2015,
  title = {Path {{Sampling}}: {{A Fast}} and {{Provable Method}} for {{Estimating}} 4-{{Vertex Subgraph Counts}}},
  shorttitle = {Path {{Sampling}}},
  booktitle = {Proceedings of the 24th {{International Conference}} on {{World Wide Web}}},
  author = {Jha, Madhav and Seshadhri, C. and Pinar, Ali},
  year = {2015},
  month = may,
  series = {{{WWW}} '15},
  pages = {495--505},
  publisher = {{International World Wide Web Conferences Steering Committee}},
  address = {{Republic and Canton of Geneva, CHE}},
  doi = {10.1145/2736277.2741101},
  urldate = {2022-10-11},
  abstract = {Counting the frequency of small subgraphs is a fundamental technique in network analysis across various domains, most notably in bioinformatics and social networks. The special case of triangle counting has received much attention. Getting results for 4-vertex patterns is highly challenging, and there are few practical results known that can scale to massive sizes. Indeed, even a highly tuned enumeration code takes more than a day on a graph with millions of edges. Most previous work that runs for truly massive graphs employ clusters and massive parallelization. We provide a sampling algorithm that provably and accurately approximates the frequencies of all 4-vertex pattern subgraphs. Our algorithm is based on a novel technique of 3-path sampling and a special pruning scheme to decrease the variance in estimates. We provide theoretical proofs for the accuracy of our algorithm, and give formal bounds for the error and confidence of our estimates. We perform a detailed empirical study and show that our algorithm provides estimates within 1\% relative error for all subpatterns (over a large class of test graphs), while being orders of magnitude faster than enumeration and other sampling based algorithms. Our algorithm takes less than a minute (on a single commodity machine) to process an Orkut social network with 300 million edges.},
  isbn = {978-1-4503-3469-3},
  keywords = {graphlet distribution,motif counting,path sampling,sampling algorithms,subgraph counting},
  file = {C\:\\Users\\Lewis\\Zotero\\storage\\KZWNLFN4\\Jha et al. - 2015 - Path Sampling A Fast and Provable Method for Esti.pdf}
}

@article{lapaughEvenpathProblemGraphs1984,
  title = {The Even-Path Problem for Graphs and Digraphs},
  author = {Lapaugh, Andrea S. and Papadimitriou, Christos H.},
  year = {1984},
  journal = {Networks},
  volume = {14},
  number = {4},
  pages = {507--513},
  issn = {1097-0037},
  doi = {10.1002/net.3230140403},
  urldate = {2023-03-29},
  abstract = {We give a simple linear-time algorithm for finding even-length simple paths between two specified nodes of a given graph. We show that the same problem for directed graphs is NP-complete.},
  langid = {english},
  file = {C\:\\Users\\Lewis\\Zotero\\storage\\E8EWW2DW\\Lapaugh and Papadimitriou - 1984 - The even-path problem for graphs and digraphs.pdf;C\:\\Users\\Lewis\\Zotero\\storage\\UM7M2G4W\\net.html}
}

@inproceedings{libkinRegularPathQueries2012,
  title = {Regular Path Queries on Graphs with Data},
  booktitle = {Proceedings of the 15th {{International Conference}} on {{Database Theory}}},
  author = {Libkin, Leonid and Vrgo{\v c}, Domagoj},
  year = {2012},
  month = mar,
  series = {{{ICDT}} '12},
  pages = {74--85},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2274576.2274585},
  urldate = {2023-03-31},
  abstract = {Graph data models received much attention lately due to applications in social networks, semantic web, biological databases and other areas. Typical query languages for graph databases retrieve their topology, while actual data stored in them is usually queried using standard relational mechanisms. Our goal is to develop techniques that combine these two modes of querying, and give us query languages that can ask questions about both data and topology. As the basic querying mechanism we consider regular path queries, with the key difference that conditions on paths between nodes now talk not only about labels but also specify how data changes along the path. Paths that combine edge labels with data values are closely related to data words, so for stating conditions in queries, we look at several data-word formalisms developed recently. We show that many of them immediately lead to intractable data complexity for graph queries, with the notable exception of register automata, which can specify many properties of interest, and have NLogspace data and Pspace combined complexity. As register automata themselves are not easy to use in querying, we define two types of extensions of regular expressions that are more user-friendly, and develop query evaluation techniques for them. For one class, regular expressions with memory, we achieve the same bounds as for automata, and for the other class, regular expressions with equality, we also obtain tractable combined complexity of query evaluation. In addition, we show that results extends to analogs of conjunctive regular path queries.},
  isbn = {978-1-4503-0791-8},
  keywords = {data values,graph databases,register automata,regular expressions,regular path queries},
  file = {C\:\\Users\\Lewis\\Zotero\\storage\\5TKK9FLT\\Libkin and Vrgoč - 2012 - Regular path queries on graphs with data.pdf}
}

@inproceedings{martensEvaluationEnumerationProblems2018,
  title = {Evaluation and {{Enumeration Problems}} for {{Regular Path Queries}}},
  booktitle = {21st {{International Conference}} on {{Database Theory}} ({{ICDT}} 2018)},
  author = {Martens, Wim and Trautner, Tina},
  editor = {Kimelfeld, Benny and Amsterdamer, Yael},
  year = {2018},
  series = {Leibniz {{International Proceedings}} in {{Informatics}} ({{LIPIcs}})},
  volume = {98},
  pages = {19:1--19:21},
  publisher = {{Schloss Dagstuhl\textendash Leibniz-Zentrum fuer Informatik}},
  address = {{Dagstuhl, Germany}},
  issn = {1868-8969},
  doi = {10.4230/LIPIcs.ICDT.2018.19},
  urldate = {2023-03-20},
  isbn = {978-3-95977-063-7},
  keywords = {graph databases,parameterized complexity,regular languages,regular path queries},
  file = {C\:\\Users\\Lewis\\Zotero\\storage\\VRZ672SA\\Martens and Trautner - 2018 - Evaluation and Enumeration Problems for Regular Pa.pdf;C\:\\Users\\Lewis\\Zotero\\storage\\FPUQUAGP\\8594.html}
}

@misc{SPARQLQueryLanguage,
  title = {{{SPARQL}} 1.1 {{Query Language}}},
  urldate = {2023-03-28},
  howpublished = {https://www.w3.org/TR/sparql11-query/\#propertypaths},
  file = {C\:\\Users\\Lewis\\Zotero\\storage\\963JM3MB\\sparql11-query.html}
}

@article{valiantComplexityComputingPermanent1979,
  title = {The Complexity of Computing the Permanent},
  author = {Valiant, L. G.},
  year = {1979},
  month = jan,
  journal = {Theoretical Computer Science},
  volume = {8},
  number = {2},
  pages = {189--201},
  issn = {0304-3975},
  doi = {10.1016/0304-3975(79)90044-6},
  urldate = {2023-03-29},
  abstract = {It is shown that the permanent function of (0, 1)-matrices is a complete problem for the class of counting problems associated with nondeterministic polynomial time computations. Related counting problems are also considered. The reductions used are characterized by their nontrivial use of arithmetic.},
  langid = {english},
  file = {C\:\\Users\\Lewis\\Zotero\\storage\\CEUHZUF3\\Valiant - 1979 - The complexity of computing the permanent.pdf;C\:\\Users\\Lewis\\Zotero\\storage\\EGGLVVSB\\0304397579900446.html}
}

@misc{WikidataSPARQLQuery,
  title = {Wikidata:{{SPARQL}} Query Service/Queries/Examples/Advanced - {{Wikidata}}},
  urldate = {2023-03-28},
  howpublished = {https://www.wikidata.org/wiki/Wikidata:SPARQL\_query\_service/queries/examples/advanced\#Locations\_of\_archaeological\_sites,\_with\_images},
  file = {C\:\\Users\\Lewis\\Zotero\\storage\\IML7GN8T\\advanced.html}
}

@article{yenFindingShortestLoopless1971,
  title = {Finding the {{K Shortest Loopless Paths}} in a {{Network}}},
  author = {Yen, Jin Y.},
  year = {1971},
  month = jul,
  journal = {Management Science},
  volume = {17},
  number = {11},
  pages = {712--716},
  publisher = {{INFORMS}},
  issn = {0025-1909},
  doi = {10.1287/mnsc.17.11.712},
  urldate = {2023-03-29},
  abstract = {This paper presents an algorithm for finding the K loopless paths that have the shortest lengths from one node to another node in a network. The significance of the new algorithm is that its computational upper bound increases only linearly with the value of K. Consequently, in general, the new algorithm is extremely efficient as compared with the algorithms proposed by Bock, Kantner, and Haynes [2], Pollack [7], [8], Clarke, Krikorian, and Rausan [3], Sakarovitch [9] and others. This paper first reviews the algorithms presently available for finding the K shortest loopless paths in terms of the computational effort and memory addresses they require. This is followed by the presentation of the new algorithm and its justification. Finally, the efficiency of the new algorithm is examined and compared with that of other algorithms.}
}
